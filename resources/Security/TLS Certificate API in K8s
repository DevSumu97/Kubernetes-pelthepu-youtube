Certificate API 
As an administrator of the cluster, in the process of setting up the whole cluster, have set up a CA server and a bunch of certificates for various components.
We then started the services using the right certificates and is all up and working.I have my own admin certificate and key.
A new admin comes into my team. She needs access to the cluster. We need to get her a pair of certificate and key pair for her to access the cluster.
She creates her own private key, generates a certificate signing request and sends it to me since I'm the only admin. 

üß© Step 1: She Generate Private Key and CSR File
openssl genrsa -out user.key 2048
openssl req -new -key user.key -subj "/CN=myuser/O=mygroup" -out user.csr
Here:
CN ‚Üí Common Name (username)
O ‚Üí Organization (maps to Kubernetes group)

I then take the certificate signing request to my CA server. Gets it signed by the CA server using the CA server's private key and root certificate, Effect, there by generating a certificate, and then sends the certificate back to her. 
She now has her own valid pair of certificate and key that she can use to access the cluster. 
The certificates have a validity period. It ends after a period of time. Every time it expires, we follow the same process of generating a new CSR and getting it signed by the CA. 

CA Server => What is the CA server and where is it located in the Kubernetes setup? 
===================================================================================
The CA is just a pair of key and certificate files we have generated. Whoever gains access to these pair of files can sign any certificate for the Kubernetes environment. 
They can create as many users as they want with whatever privileges they want. So these files need to be protected and stored in a safe environment. So we place them on a server that is fully secured. Now that server becomes your CA server. 
The certificate key file is safely stored in that server and only on that server. Every time you want to sign a certificate, you can only do it by logging in to that server.
As of now, we have the certificates placed on the Kubernetes master node itself. So the master node is also CA server. 
So far we have been signing requests manually, but as and when the users increase and your team grows, you need a better automated way to manage the certificates signing requests,
as well as to rotate certificates when they expire.Kubernetes has a built-in certificates API that can do this for you.

With the certificates API, you now send a certificate signing request directly to Kubernetes through an API call. This time, when the administrator receives a certificate signing requests instead of loggingon to the master node and signing the certificate by himself, he creates a Kubernetes API object called certificate signing request.

üß© Step 2: Create CSR YAML => Encode the user.csr file in base64 (single line):

cat user.csr | base64 | tr -d "\n"

Then create a manifest like this:

apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: myuser-csr
spec:
  request: <BASE64_ENCODED_CSR_CONTENT>
  signerName: kubernetes.io/kube-apiserver-client
  usages:
    - client auth

Apply it: kubectl apply -f csr.yaml

Once the object is created, all certificate signing requests can be seen by administrators of the cluster. The requests can be reviewed and approved easily using kube control commands.

üß© Step 3: View & Approve the CSR

List CSRs: kubectl get csr

Approve the CSR: kubectl certificate approve myuser-csr

If you want to deny: kubectl certificate deny myuser-csr

This certificate can then be extracted and shared with the user. Let's see how it is done. 

üß© Step 4: Retrieve the Signed Certificate

Once approved, Kubernetes CA signs it and you can fetch it:

kubectl get csr myuser-csr -o jsonpath='{.status.certificate}' | base64 --decode > user.crt

Now you have:
user.key ‚Üí private key
user.crt ‚Üí signed certificate

You can use these with kubectl by creating a new kubeconfig user.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Example of jane
=============
A user first creates a key, then generates a certificate signing request using the key with her name on it, then sends the request to the administrator. 

openssl genrsa -out jane.key 2048 => Generates an RSA private key. 
openssl req -new -key jane.key -subj "/CN=jane" -out jane.csr => Creates a Certificate Signing Request (CSR) using the private key. 

The administrator takes a jane.csr and creates a certificate signing request object. 
The certificate signing request object is created like any other Kubernetes object, using a manifest file with the usual fields,.
kind => certificate signing request 
Under the spec section=> request field => Is where you specify the certificate signing request sent by the user, but you don't specify it as plain text. 
Instead, it must be encoded using the base64 command. (cat jane.csr | base 64) Then move the encoded text into the request field and then submit the request.

vi jane.yaml

apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: jane
spec:
  request: <BASE64_ENCODED_CSR_CONTENT> encoded o/p of => cat jane.csr | base 64
  signerName: kubernetes.io/kube-apiserver-client
  usages:
    - client auth

K apply -f jane.yaml

once the object is created. All certificate signing requests can be seen by administrators by running = k get csr =>o/p => jane 
Identify the new request and approve the request by => k certificate approve jane 

This certificate can then be extracted and shared with the user. 
View the certificate by viewing it in a YAML format. => k get csr jane -o yaml The generated certificate is part of the output, but as before, it is in a base64 encoded format.
To decode it, take the text and use the base64 utilities decode option. => echo ‚Äúencoded certificate‚Äù | base 64   => This gives the certificate in a plain text format.
This can then be shared with the end user.

You now have jane.key (private key) and jane.crt (signed certificate) for authentication.
--------------------------------------------------------------------------------------------------------------------------------------------------------

All the certificate-related operations are carried out by the controller manager. 
If you look closely at the Controller manager, you will see that it has controllers in it called CSR approving, CSR signing, etc. responsible for carrying out these specific tasks. 
We know that if anyone has to sign certificates, they need the CA server's root certificate and private key. 
The Controller Manager service configuration has two options where you can specify this. 

So far we have seen how to generate a private key & certificate for a user. 
We have seen how a client uses the certificate file and key to query the Kubernetes Rest API for a list of pods using curl. 
In this case, my cluster is called Minikube playground. 
So send a curl request to the address of the kube API server while passing in the pair of files, along with the certificate as options. 
This is then validated by the API server to authenticate the user.

curl https://my-kube-playground:6443/api/v1/pods \ 
--key admin.key \ 
--cert admin.crt \ 
--cacert ca.crt 

Now how do you do that while using the kube-control command? 
You can specify the same information using the options server, client key, client certificate and certificate authority with the kube-control utility. 

kubectl get pods \ 
--server my-kube-playground:6443 \ 
--client-key admin.key \ 
--client-certificate admin.crt \ 
--certificate-authority ca.crt 

Obviously, typing those in every time is a tedious task. So you move this information to a configuration file called as config,and then specify this 
file as the kubeconfig option in your command. 

kubectl get pods --kubeconfig config

By default, the kubecontrol tool looks for a file named ‚Äúconfig‚Äù under a directory .kube (hidden directory) under the user's home directory. $HOME/.kube/config
So if you create the kubeconfig file there, you don't have to specify the path to the file explicitly in the kubecontrol command. 
That's the reason you haven't been specifying any options for your kubecontrol commands so far. 

The Kubeconfig file is in a specific format. Let's take a look at that. 
The config file has three sections clusters, users, and contexts. 

Clusters are the various Kubernetes clusters that you need access to. So you have multiple clusters for development environment or testing environment, or prod,
or for different organizations, or on different cloud providers, etc. all those go there. 

Users are the user accounts with which you have access to these clusters, for example the admin user, a dev user, a prod user, etc. 
These users may have different privileges on different clusters.

Finally, contexts marry these together. Context define which user account will be used to access which cluster. 
For example, you could create a context named admin@production that will use the admin account to access production cluster

Remember, you're not creating any new users or configuring any kind of user access or authorization in the cluster. With this process,
you're using existing users with their existing privileges and defining what user you're going to use to access what cluster. 
That way, you don't have to specify the user certificates and server address in each and every kubecontrol command you run. 

So how does it fit into our example? 

The server specification in our command goes into the cluster section. (--server my-kube-playground:6443 & --certificate-authority ca.crt) 

The admin user's keys and certificates goes into the users section. ( --client-key admin.key --client-certificate admin.crt) 

You then create a context that specifies to use the Mykube admin user to access the Mykube playground cluster.
Mykube admin @ Mykube playground 

Let's look at a real Kubeconfig file. 
Now the Kubeconfig file is in YAML format. 
It has API version set to v1. 
The kind is config and then it has three sections as we discussed. One for clusters, one for contexts, and one for users. 
Each of these is in an array format. That way you can specify multiple clusters, users, or contexts within the same file. 

Under clusters, we add a new item for our Kube-Playground cluster. 
We name it Mykube Playground and specify the server address under the server field. 
It also requires the certificate of the certificate authority. 

We can then add an entry into the users section to specify details of my kube admin user, provide the location of the client certificate and key pair. 
So we have now defined the cluster and the user to access the cluster. 

Next, we create an entry under the context section to link the two together. 
We will name the context my kube admin at my kube playground. My-kube-admin@my-kube-playground. 
We will then specify the same name we used for cluster and user. Follow the same procedure to add all the clusters. 

Once the file is ready, remember that you don't have to create any object like you usually do for other Kubernetes objects. 
The file is left as is and is read by the kube control command and the required values are used. 

Now how does kube control know which context to choose from? We have defined three contexts here. Which one should it start with? 
You can specify the default context to use by adding a field current context to the kubeconfig file. Specify the name of the context to use. 

To view the current file being used, run the kube control config view command. 

=> kubectl config view 

As we discussed earlier, if you do not specify which kubeconfig file to use, it ends up using the default file located in the folder dot kube
(.kube -hidden directory) in the user's home directory.
 Alternatively, you can specify a kubeconfig file by passing the kube config option in the command line like this. 
 ---
 
 We will move our custom config to the home directory, so this becomes our default config file. 
 
 So how do you update your current context?
 Can you configure a context to switch to a particular namespace? 
 The context section in the Kubeconfig file can take additional field called namespace, where you can specify a particular namespace. 
 This way when you switch to that context, you will automatically be in a specific namespace. 
 
 There are 2 ways to mention the certificate credentials Well, it's better to use the full path.
 Instead of using certificate authority field and the path to the file you may optionally use the Certificate Authority data field and provide the contents 
 of the certificate itself, but not the file as is. Convert the contents to a base64 encoded format and then pass that in.
