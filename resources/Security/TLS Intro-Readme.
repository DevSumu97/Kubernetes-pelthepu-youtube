 TLS Basics - https://youtu.be/njT5ECuwCTo?si=GBUmw62VsERs-yA6
Security-7 

TLS- Basics 
==========

Communication b/w User and server in a plain text format
==========================================================
User- Try to GET some data from the server. 
Server- Servers asks for Identification. 
User- Sends his Credentials (Username & password) in the plain text format.
Server- Authenticate the credentials and the send the requested data to User.
Hacker- Sniffing the network traffic could easily retrieve the credentials in the plain text format and use it to get the data from server. Now u are hacked.

Communication b/w User and server by following the Symmetric Encryption
=====================================================================
In Symmetric encryption will use a single key for both encrypt & decrypt. In Symmetric encryption our credentials (username and password) is encrypted by a symmetric key and the same key must be send to the Server to decrypt the credentilas for authentication. But while sharing the key . Hacker- Sniffing the network traffic could easily retrieve the key. For this reason, symmetric encryption is not preferred. 

Now we use both Symmetric and Asymmetric encryption to secure the connection b/w user and Server
==============================================================================================

User – Will follow symmetric encryption and has a Single key (u-symm-key) to encrypt and decrypt. 
Whereas the Server follows Asymmetric encryption and generate a public and private key by the openssl utility. 


=> openssl genrsa -out mybank.key 2048  => generates a 2048-bit RSA private key and saves it to a file named mybank.key.

Explanation:
openssl: This is the command-line tool for using the OpenSSL cryptography library.
genrsa: This tells OpenSSL to generate an RSA private key.
-out mybank.key: This specifies the output file for the private key.
2048: This is the size of the key in bits (2048 bits).

 
=> openssl rsa -in mybank.key -pubout -out mybank.pub => To create a public key from the private key (mybank.key)

openssl rsa: This tells OpenSSL to work with RSA keys.
-in mybank.key: This specifies the input file (the private key).
-pubout: This tells OpenSSL to output the corresponding public key.
-out mybank.pub: This specifies the output file for the public key.

server-private.key – Stays with the server, Used to decrypt the data.
server-public.key – Shared to User, Used to encrypt the data 

Process of establishing Secure connection
========================================
1.When user requests/ping the server for data, the Server will share its public key (s-public.key) to the user and to authenticate you as a valid user asked to share his credentials. 2.User follows symmetric encryption method, and he encrypt his credentials by using his symmetric key (u-symm-key) and he encrypt his symmetric-key by using the server’s public key (s-public.key)
3.Now the encrypted credentials and the encrypted user symmetric key will be shared to the server. 
4.Now hackers will get encrypted credentials & both the encrypted user symmetric key ( u-symm-key) and the server’s public key (s-pub-key). But he can’t decrypt bcoz he doesn’t have the server’s private key (s-private-key).In this way we established a secure connection. 

But Still, we have a loophole, now let’s try to fix it.

Now Hacker will go one step further and create a dummy website which looks similar to a real banking website and user will interact with this website/server managed by the hacker. 
Here website might be a banking website asking username and password to login to the net banking. When the user makes a get request to the server/website managed by the hacker, it will share its public key and request user to share his credentials to authenticate whether he is a valid user or not.

Now the user has no idea it’s a hacker’s website/server. User will share his credentials by encrypting it with his u-symm key and also, he shares the encrypted u-symm key (which was encrypted by hacker’s public key). Now the hacker will have encrypted u-symm key, h-public-key & h-private key…now he will decrypt the encrypted u-symm key by h-private key and do whatever he wants. (h-hacker)

Now we will see, is there any way to ensure we are getting a reply from the right server? 

Generally, when we do a GET request to server, it will response back with its public key, but we are not sure whether this is the public key of the server or hacker who is acting as a proxy for the server.
What if there was a way to validate this replay is from a right server or not. So that’s why instead of using only public key and private key will use the certificate.
Now user will receive the certificate along with public key and this will be validated by the user’s website by checking that this certificate is issued to the domain what we pinged.
Then user will encrypt his u-symm key with the s-public-key avilable on the certificate and send to the server. This will be a secure connection.

when the server sends the publick key, it does not send the key alone. It sends a certificate that has the key in it. It has information about who the certificate is issued to, the public key of that server, the location of the server. Every certificate has a name on it, the person or subject to whom the certificate is issued to. That is very important as that is the field that helps you validate their identity is this is for a web server. This must match what the user types in the URL on his browser. If the bank is known by any other names, and if they like their users to access their application with the other names as well, then all those names should be specified in this certificate under the subject Alternative Names section.

Who signed and issued the certificate is Important ?
If you generated a certificate and sign it by yourself. That is known as a self-signed certificate.


If you looked at the certificate you received from the hacker closely, you would have noticed that it was a fake certificate that was signed by the hacker himself. As a matter of fact, your browser does that for you. All of the web browsers are built in with a certificate validation mechanism, wherein the browser checks the certificate received from the server and validates it to make sure it is legitimate. If it identifies it to be a fake certificate, then it actually warns you.

How the server will get the certificate. Server will raise the Certificate Signing Request (CSR)and submit to a Certificate Authority (CA). Certificate authority will validate and sign the CSR with its private key. But how do the browsers know that the CA itself was legitimate? The CAs themselves have a set of public and private key pairs. The CAs use their private keys to sign the certificates. The public keys of all the CAs are built into the browsers. The browser uses the public key of the CA to validate that the certificate was actually signed by the CA themselves. 

So then how do you create a legitimate certificate for your web servers that the web browsers will trust?
How do you get your certificates signed by someone with authority? That's where certificate authorities comes in.
They're well known organizations that can sign and validate your certificates for you. Some of the popular ones are Symantec, Digicert, Comodo, Globalsign, etc..

The way this works is you generate a certificate signing request or CSR using the private key you generated earlier and the domain name of your website.

=> openssl req -new -key my-bank.key -out my-bank.csr -subj "/C=US/ST=CA/O=MyOrg, Inc/CN=my-bank.com"

Breakdown of options:
req: Use the certificate request (CSR) generation command.
-new: Create a new CSR.
-key my-bank.key: Use this existing private key to sign the CSR.
-out my-bank.csr: Output the CSR to this file.
-subj "/C=US/ST=CA/O=MyOrg, Inc/CN=my-bank.com": Provides subject details non-interactively:
C = Country (US)
ST = State (CA)
O = Organization (MyOrg, Inc) Inc- InCorporation
CN = Common Name (domain) → my-bank.com

✅ Result:
It generates a CSR file named my-bank.csr, which can then be sent to a Certificate Authority (CA) to obtain an SSL/TLS certificate.

The certificate authorities verify your details and once it checks out, they sign the certificate and send it back to you.
You now have a certificate signed by a CA that the browsers trust.

If hacker tried to get his certificate signed the same way, he would fail during the validation phase and his certificate would be rejected by the CA. So the website that he is hosting won't have a valid certificate.

But how do browsers know that the CA itself was legitimate?

The CA themselves have a set of public and private key pairs. 
The CA's used their private keys to sign the certificates. 
The public keys of all the CAS are built in to the browsers.
The browser uses the public key of the CA to validate that the certificate was actually signed by the CA themselves ( You can actually see them in the settings of your web browser under certificates. They are under trusted CAS tab.)


Summary 
We've seen why you may want to encrypt messages being sent over a network. To encrypt messages, we use asymmetric encryption with a pair of public and private keys.

An admin uses a pair of keys to secure SSH connectivity to the servers. 

✅  ssh-keygen

This creates two files:
~/.ssh/id_rsa → Private key (keep this safe!) (/home/<user>/.ssh/id_rsa by default it saves in this path)
~/.ssh/id_rsa.pub → Public key (can be shared or added to servers)

✅ To Copy Public Key to a Remote Server under the path /.ssh/authorized_keys
ssh-copy-id user@remote_host

✅ Then just connect to server by: ssh user@server_ip


The server uses a pair of keys to secure a HTTPS traffic.But for this, the server first sends a certificate signing request to a CA, the CA uses its private key to sign the CSR. Remember, all users have a copy of the CAs public key. The signed certificate is then sent back to the server. The server configures the web application with the signed certificate. Whenever a user accesses the web application, the server first sends the certificate with its public key. The user, or rather the user's browser reads the certificate and uses the CAs public key to validate and retrieve the server's public key. User then generates a symmetric key that it wishes to use going forward for all communication. The symmetric key is encrypted using the server's public key and sent back to the server. The server uses its private key to decrypt the message and retrieve the symmetric key. The symmetric key is used for communication going forward.

Note -
> Administrator generates a key pair for securing SSH. 
> The web server generates a key pair for securing the website with HTTPS. 
> The certificate authority generates its own set of key pair to sign certificates.
> The end user though only generates a single symmetric key. Once he establishes trust with the website, he uses his username and password to authenticate to the web server.

Here we have one more Issue--
By the server's key pair, the client was able to validate that the server is who they say they are, but the Server does not for sure know if the client is who they say they are. 
It could be a hacker. So what can the server do to validate that the client is who they say they are?
For this, as part of the initial trust building exercise, the server can request a certificate from the client. 
So the client must generate a pair of keys and get a signed certificate from a valid CA.
The client then sends the certificate to the server for it to verify that the client is who they say they are.
This whole infrastructure, including the CA, the servers, the people, and the process of generating, distributing and maintaining digital certificates is known as public key infrastructure or PKI. 

TLS in Kubernetes 
There are three types of certificates
Server certificates configured on the servers.
Root certificate configured on the CA servers.
Client certificates configured on the clients.

Note -
Usually certificates with Public keys are named .crt or .pem extension
example, server.crt or server.pem 
certificates with Private keys are usually with extension .key or with a '-key' in the file names.
example, server.key or server-key.pem Private keys have the word key in them usually, either as an extension or in the name of the certificate. 

The Kubernetes cluster consists of a set of master and worker nodes. Of course, all communication between these nodes needs to be secure and must be encrypted. 
All interactions between all services and their clients need to be secure. 
So the two primary requirements are to have all the various services within the cluster to use server certificates and all clients to use client certificates to verify they are who they say they are.


Let's look at the different components within the Kubernetes cluster and identify the various servers and clients and who talks to who. 

Servers on the Kubernetes Cluster
=============================
Server Components On Master Node :- Kube API server exposes an HTTPS service to other components, as well as external users, use to manage the Kubernetes cluster. So it is a server and it requires a certificate to secure all communication with its clients. 
So we generate a certificate and key pair. 
We call it apiserver.cert and apiserver.key.

Kube-apiserver as a client to etcd and kublet on each nodes
========================================================
The kube-apiserver is the only server that talks to the etcd server. So as far as the etcd server is concerned, the kube-apiserver is a client. So it needs to authenticate. The kube-apiserver can use the same keys that it used earlier for serving its own API service. The apiserver.crt, and the apiserver.key files. Or you can generate a new pair of certificates specifically for the kube-apiserver to authenticate to the etcd server. (apiserver-etcd-client.crt and apiserver-etcd-client.key) 

The kube-apiserver also talks to the kubelet server on each of the individual nodes. That's how it monitors the worker nodes.
For this. Again, it can use the original certificates, or generate new ones specifically for this purpose. . (apiserver-kublet-client.crt and apiserver-kublet-client.key)

Another server in the cluster is the etcd server. 
==============================================
The etcd server stores all information about the cluster. So it requires a pair of certificate and key for itself.
We will call it etcdserver.crt and etcdserver.key.

Server Components on Worker Node :- 
=================================
The other server component in the cluster is on the worker nodes.
They are the kubelet services. They also expose an HTTPS API endpoint that the kube-apiserver talks to interact with the worker nodes. 
Again, that requires a certificate and key pair we call it kubelet.cert and kubelet.key. 

Who are the clients who access these services? 
============================================

The clients who access the kube-apiserver are us,

The administrators through kubectl rest API. 
The admin user requires a client certificate and key pair to authenticate to the kube-API server. 
We will call it admin.crt, and admin.key.

The Kube scheduler is a client that accesses the kube-apiserver. 
So the scheduler needs to validate its identity using a client TLS certificate. 
So it needs its own pair of certificate and keys. We will call it scheduler.cert and scheduler.key. 

The Kube Controller Manager is another client that accesses the kube-apiserver, so it also requires a certificate for authentication to the kube-apiserver.
So it needs its own pair of certificate and keys.
We will call it controller-manager.cert and controller-manager.key 

The last client component is the kube-proxy.
The kube-proxy requires a client certificate to authenticate to the kube-apiserver, and so it requires its own pair of certificate and keys. 
We will call them kubeproxy.crt, and kubeproxy.key. 

We need a certificate authority to sign all these certificates. Kubernetes requires you to have at least one certificate authority for your cluster. The CA, has its own pair of certificate and key.We will call it CA.crt and CA.key.

======================================

First we create a private key using the OpenSSL command =>

1. Generate a Private Key for the CA =>  openssl genrsa -out ca.key 2048

This creates a 2048-bit private key named ca.key.
This key is used to sign certificates.

2. Then we use the OpenSSL request command along with the key we just created to generate a Certificate Signing Request (CSR)
   The certificate signing request is like a certificate with all of your details, but with no signature.
   In the certificate signing request, we specify the name of the component the certificate is for in the common name or CN field.
   In this case, since we are creating a certificate for the Kubernetes CA, we name it Kubernetes CA.

=>  openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr

This creates a CSR named ca.csr, using the private key ca.key.
The -subj "/CN=KUBERNETES-CA" part sets the Common Name (CN) of the certificate to KUBERNETES-CA.
This CSR is basically a request for a certificate.

3. Finally, we sign the certificate using the OpenSSL x509 command and by specifying the certificate signing request CSR we generated in the previous command.
   Since this is for the CA itself, it is self-signed by the CA using its own private key that it generated in the first step.

 =>  openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt    => Self-sign the CSR to create a CA Certificate

This command self-signs the CSR using the ca-private key, producing the CA certificate ca.crt.
This step makes this certificate a self-signed root CA.


Going forward. For all other certificates, we will use the CA key pair to sign them. The CA now has its private key and root certificate file.

Great. Let's now look at generating the client certificates.
==========================================================

We start with the admin user.

1. Generate a Private Key for the Admin User => openssl genrsa -out admin.key 2048

Creates a 2048-bit private key named admin.key. This key will be used to generate a CSR and to identify the client (admin).

2. Generate a Certificate Signing Request (CSR) =>  openssl req -new -key admin.key -subj "/CN=kube-admin" -out admin.csr

Creates a CSR (admin.csr) with the Common Name (CN) set to kube-admin. This CN is how Kubernetes will recognize this user.

3. But this time you Sign the CSR (admin.csr) with the CA certificate and the CA key to Create the Admin Certificat . You're signing your certificate with the CA key pair. 
 That makes this a valid certificate within your cluster.
 
=>  openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt

Signs the CSR with the CA certificate (ca.crt) and private key (ca.key).Produces a client certificate named admin.crt, which is now trusted by the Kubernetes cluster.

How do you differentiate this user from any other users?
The user account needs to be identified as an admin user and not just another basic user. 
You do that by adding the group details for the user in the certificate. In this case, a group named System Masters exist on Kubernetes with administrative privileges. it's important to mention this information in your certificate signing request. You can do this by adding group details with the OU parameter while generating a certificate signing request.

=> openssl req -new -key admin.key -subj "/CN=kube-admin/OU=system:masters" -out admin.csr

🔍 Explanation of each part:
openssl req -new → Generates a new Certificate Signing Request (CSR).
-key admin.key → Uses the private key file admin.key to sign the CSR.
-subj "/CN=kube-admin/OU=system:masters" → Sets the subject information directly (so it doesn’t prompt you interactively).
CN=kube-admin → The Common Name — identifies the user (in Kubernetes, it represents the username).
OU=system:masters → The Organizational Unit — determines the user group.
In Kubernetes, users in the system:masters group have cluster-admin privileges.
-out admin.csr → Writes the output CSR to the file admin.csr.

We follow the same process to generate client certificates for all other components that access the kube API server.
The kube scheduler is a system component part of the Kubernetes control plane, so its name must be prefixed with the keyword system.SYSTEM:KUBE_SCHEDULER
The same with kube controller manager It is again a system component, so its name must be prefixed with the keyword system-> SYSTEM:KUBE_CONTROLLER MANAGER
and finally kube proxy.

So far we have created CA certificates.Then all of the client certificates including the admin user,scheduler,controller manager and kube proxy.

Similarly, in Kubernetes, for these various components to verify each other, they all need a copy of the CA's root certificate.
So whenever you configure a server or a client with certificates, you will need to specify the CA root certificate as well.

Etcd server can be deployed as a cluster across multiple servers as in a high availability environment.In that case, to secure communication between the different members in the cluster, we must generate additional peer certificates.

🔐 What is an etcd peer certificate?

In an etcd cluster, each etcd node communicates securely with other etcd nodes over mutual TLS (mTLS).
For this, each node has two kinds of certificates:

Type	Purpose	Example File
Server certificate	Used when serving requests from etcd clients (like the Kubernetes API server)	server.crt
Peer certificate	Used when communicating with other etcd members in the cluster	peer.crt

The peer certificate authenticates the node’s identity to other peers.

🧩 How peer certificates work

In an etcd cluster with multiple nodes:
Each node has a peer certificate and a peer key.
Each node verifies other nodes’ peer certificates using the CA certificate.
The certificates are mutually trusted, ensuring only valid cluster members can connect.
Communication: etcd1 <──(mTLS)──> etcd2 <──(mTLS)──> etcd3
Each uses peer.crt and peer.key for this communication.

Once the certificates are generated, specify them in etcd server.config file 
There are key and cert file options where you specify the etcd server keys.
There are other options available for specifying the peer certificates.
And finally, as we discussed earlier, it requires the CA root certificate to verify that the clients connecting to the etcd server are valid.

Creation of API Server Certificate 
===================================
In the certificate signing request you specify the name kube API server.
But how do you specify all the alternate names?
For that you must create an open SSL config file.
Create an OpenSSL conf file and specify the alternate names in the Altnames section of the file.
Include all the DNS names of the API server goes by as well as the IP address.
Pass this config file as an option while generating the certificate signing request.
Finally, sign the certificate using the CA certificate and key.
You then have the API server certificate.

 👏 —API Server certificate creation using OpenSSL, along with a custom configuration file (openssl.cnf) to include Subject Alternative Names (SANs).

🧩 Step 1: Create the Certificate Signing Request (CSR)
openssl req -new -key apiserver.key -subj "/CN=kube-apiserver" -out apiserver.csr -config openssl.cnf

📄 Step 2: openssl.cnf — Configuration File

[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
IP.1 = 10.96.0.1
IP.2 = 172.17.0.87

Breakdown:
req_extensions = v3_req → Tells OpenSSL to use the [v3_req] section when creating the CSR.
subjectAltName = @alt_names → Adds SANs (used to verify hostnames or IPs).
DNS.* entries → Common service names the API server can be accessed with.
IP.* entries → The cluster’s API server IPs (for example, 10.96.0.1 is the default Kubernetes service IP).
Without these SANs, Kubernetes clients (like kubectl) would show TLS verification errors.

🔏 Step 3: Sign the CSR with the Kubernetes CA
openssl x509 -req -in apiserver.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out apiserver.crt -extensions v3_req \
-extfile openssl.cnf -days 1000

Explanation:
-req → Tells OpenSSL you’re signing a CSR.
-CA ca.crt -CAkey ca.key → Signs using your Kubernetes cluster’s CA.
-extensions v3_req -extfile openssl.cnf → Ensures SANs and other extensions are included.
-days 1000 → Certificate validity period (1000 days here).
Output: apiserver.crt — your signed certificate.

Server Certificate for  kubelet
==============================
The Kubelet server is an https API server that runs on each node responsible for managing the node.
That's who the API server talks to to monitor the node, as well as send information regarding what pods to schedule on this node.
As such, you need a key certificate pair for each node in the cluster.

Now what do you name these certificates?
Are they all going to be named kubelets? No, they will be named after their nodes. Node-0,Node-1 and Node-2.
Once the certificates are created, use them in the kubelet config file.
As always, you specify the root certificate and then provide the Kubelet node certificates.
You must do this for each node in the cluster.

Client Certificate for kubelet
==============================
We also talked about a set of client certificates that will be used by the Kubelet to communicate with the kube API server.
These are used by the Kubelet to authenticate themself with the kube API server. They need to be generated as well.

What do you name these certificates?
The API server needs to know which node is authenticating and give it the right set of permissions.
So it requires the nodes to have the right names in the right format.
Since the nodes are system components the format starts with the system keyword followed by node and then the node name.=> System:Node:Node01

And how would the API server give it the right set of permissions?
Remember we specified a group name for the admin user. So the admin user gets administrative privileges.
Similarly, the nodes must be added to a group named system nodes.
