Youtube:-https://youtu.be/c8LBjmFPjM4?si=0yV0vNqg-eHQbnHu

> If you look at the mongodb deployment or stateful set we created in the previous sections of this series we have configured few properties like username password Etc > This way we can easily change them without rebuilding the actual image in this section we will learn how to pass the same configuration data to Containers using config maps and secrets.

> whenever we develop any application we should not hard code the properties which change for each environment instead we should configure those properties so that we don't need to rebuild the image whenever these values change.
>All we do is just pass those values from outside. That way we can reuse the same image for different environments like Dev,QA,staging & production
 
  There are three different ways we can give the configuration data to any application.
		> passing as arguments 
		> configuration files 
		> using environment variables


> We tried couple of them already but hard codig this data even in the Pod definition is not a good idea.
> As we need different pod definitions for each environment.
> To reuse the same pod definition in different environments it makes sense to define the configuration data in a common place and refer to that data from the Pod descriptor.
> For this purpose kubernetes provides 2 special types of volumes which are 
  > config map  
  > Secret 

 These two kubernetes resources are used for setting configuration data separately from pod manifest files.
> let  us learn about these two special resources in detail starting with config map.
> config map is a kubernetes object that lets you store configuration which can be used in different applications let us try to create a simple config map and see how it can be used.
> let's go to vs code and create a file with name mongo-configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata: 
  name: mongodb-config
immutable: false
data:
  username: admin1        (key is username & admin is value)
  password: password       (key is password & password is value)
  mongodb.conf: |           (key is the file name mongodb.conf)
    storage:
      dbPath: /data/configdb
    replication:
        replSetName: "rs0"

> here version is V1, kind is the config map, In metadata we can use the name as mongodb-config.

> unlike most kubernetes object that have a "spec" a config map has "data" field.
> so instead of "spec" we will have data field. This data field accepts key value pairs as their values.
> let's configure the "username as admin" and "password as password" .
> basically we are configuring the mongodb username and password in a config map.
> Not only just "string values"  .But we can als define the configuration files in the config map.
> As an example we will create a simple mongodb config file in which we will give the DB path and replica set name.
> for that let's add key mongodb.conf

 storage:
      dbPath: /data/configdb
    replication:
        replSetName: "rs0"

 This is the file content. As this is a multi-line string and we want to preserve the new lines... we should give a pipe symbol denoting this as a literal block.
> please note that a config map is not designed to hold large chunks of data the data stored in a config map cannot exceed 1 MB.
> If you need to Store settings that are larger than this limit you may want to consider mounting a volume or using a separate database or file service.
> For any security reasons if you don't want anyone to update this config map just add another attribute with the name "immutable" with the value "true"
> when this is "true" the config map cannot be updated it can only be deleted and recreated.
>The default value is "false" which means we can edit the config map.
> for now let us go with a immutable config map.
> now let's try to apply this config map==> ## kubectl apply -f mongo-configmap.yaml
> Now the config map is created... we can verify that with ## kubectl get cm .==> cm is the short name for the config map.
> As you can see we have a config map with the name-mongodb-config with the three keys.

NMAE            DATA   AGE 
mondodb-config  3      16s 

> Now that we have a config map... let us see how to use it in our stateful set.
> we can use this "config map data as environment variables" .
> previously we hard-coded the username and password instead of hard coding.. let's try to get this data from the config map that we created.
> so let's delete this and instead of value we should give value from and we should give configmapkeyref and the key that we are referring from the config map is the username and the config map name is mongodb-config.
>This is the config map we just created and this key refers to the key that we defined here.

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongo
spec:
  selector:
    matchLabels:
      app: mongo
  serviceName: "mongo"
  replicas: 3
  template:
    metadata:
      labels:
        app: mongo
    spec:
      containers:
        - name: mongo
          image: mongo:4.0.8
          env:
            - name: MONGO_INITDB_ROOT_USERNAME
              valueFrom:
                configMapKeyRef:
                  key: username
                  name: mongodb-config      (Name of the confingmap)
            - name: MONGO_INITDB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: mongodb-secret     (Name of the secret)
          command:
            - mongod
            - "--bind_ip_all"
	    - --config=/etc/mongo/mongodb.conf    (using config file from configmap)
          volumeMounts:
            - name: mongo-volume
              mountPath: /data/db
            - name: mongodb-config
              mountPath: /etc/mongo
      volumes:
        - name: mongodb-config      (Name of the volume)
          configMap:
            name: mongodb-config    ( Name of the config map)
            items:
              - key: mongodb.conf  
                path: mongodb.conf
  volumeClaimTemplates:
    - metadata:
        name: mongo-volume
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: demo-storage
        resources:
          requests:
            storage: 1Gi


> let us try to do the same for the password so value from configmapkeyref.
> here key name is password and the name of the config map is mongodb-config 
> That's it now this container uses the configuration data from the config map.
> If you look at the config map we also Define the custom mongodb configuration file (mongodb.conf)
> let us try to see how we can use this configuration file in the stateful set.
> To use a custom configuration file, we should pass that configuration file path when we are starting the mongo
> so let us try to give the configuration file as an argumet (--config=/etc/mongo/mongodb.conf) 
> But where is this file located? 
> how does stateful State pulls this file from the config map?
> In order to to load this file this file should exist on the container.
> so as a first step we should create this file in the container using volumes.

> please note that "config map and secrets are special types of volumes."
========================================================================
> so let us try to mount the special type of config map volume onto the container.
> For that we should declare the volumes first.. this volume should be at the container level.

volumes:
        - name: mongodb-config
          configMap:
            name: mongodb-config
            items:
              - key: mongodb.conf
	      - path: mongodb.conf

> so volumes and 
> let's give the # volume name as ==> "mongodb-config"  
> The # Type of the volume as ==>  "config map"  
> The name of the config map is ==> "mongodb-config"
> As we have three keys in the config map we should give which key should go as a file.
> so we need mongodb.conf and we can give that with "items" and this is an array 
> ==> keys: mongodb.conf   => so this is the key from the config map
> ==> path: mongodb.conf =>  This is the name with which the file is created 

> perfect now that we have the volume defined ...we should Mount this volume into the Container.

volumeMounts:
            - name: mongo-volume
              mountPath: /data/db
            - name: mongodb-config
              mountPath: /etc/mongo


> so let's go to the volume mount section and let's Mount this with the name as "mongodb-config" and the mount path is /etc/mongo
> that's it now let's try to apply this stateful set. ==> kubectl apply -f statefulset.yml
> Kubectl get pods -w	
> Three pods are running ( mongo-0,mongo-1,mongo-2)
> Please note that the config map and the Pod that uses this config map must be in the same namespace.

> Now let's get into the Pod and see if the environment variables from our config map and also the configuration from our config map are mounted correctly or not.
> For that ==> kubectl exec -it mongo-0 --bash
> so now let's list down the environment variables =>## env
> As you can see the username environment variable is here and the password environment variable is here.
> so let's see the configuration file is mounted or not.
> for that ==>  cat/etc/mongo/mongodb.com 
> As you can see this is the configuration file that we gave in the config map and that is mounted into the Container.
> so this way we can use the config map data into a pod.
> please note that config map doesn't differentiate between single end property values and multi-line file like values.
> what matters is how pods and other objects consume those values.. we consume these values as environment variables and we consume this value as a file.
> perfect now we have decoupled the configuration from the pod Manifest this config map can be used by any number of pods.
> If you want to change this data all we need to change is the config map and it will be reflected in all the pods that use this config map.

apiVersion: v1
kind: ConfigMap
metadata: 
  name: mongodb-config
immutable: false
data:
  username: admin1         (key is username & admin1 is value)
  password: password       (key is password & password is value)
  mongodb.conf: |           (key & file name)
    storage:
      dbPath: /data/db  => (configDB to just db)
    replication:
        replSetName: "rs0"

> let's update the config map and see.. let's change the DB path from "configDB to just db" and also let's change the username from "admin to admin1"
> let's save it and apply the changes.
> let's come out of the container ==> exit 
> ##Kubectl apply -f configmap.yml  ==>  as you can see the config map is updated 
> now let's get into the Pod and see if the values are updated automatically/not => ## kubectl exec -it mongo-0 --bash
> so let's list on the file contents of the mongodb.conf==> cat /etc/mongo/mongodb.conf===>  cool it's updated 
> Now let's check the environment variables==>## env ==>  it's not updated ..This is because config Maps consumed as volumes are updated automatically but config Maps consumed as environment variables are not updated automatically and requires a pod restart .
so let's restart the Pod and see if it is updated or not.
> exit the container so let's delete the pod ==>## kubectl delete pod mongo-0 and the pod should automatically get created because we are using the stateful-set .
> so now let's get into the same pod ## kubectl exec -it mongo-0 --bash and list all the environment variables => ## env and as you can see the environment variable is updated.
> Also we can list dwon the ls/data/db to see if the data is getting stored there or not.
> As you can see the data is storing in the newly updated location.
> but wait a minute this password is the confidential data and there might be other confidential information like API keys and certificates which we don't want everyone to see.
>To configure such confidential data kubernetes provides another type of volume secrets.
> config maps and secrets are almost same in terms of how we create them and use them.
> The only difference is that secrets are secure.
> The data of the secrets can be encrypted in etcd database.
> let's create a simple secret and see how it looks like=> mongo-sectret.yml
> let's copy paste the same config map and try to update it.


apiVersion: v1
kind: Secret
metadata: 
  name: mongodb-secret
immutable: false
type: Opaque
data:
  password: cGFzc3dvcmQxMjM=           (password  base 64 encrypted string  cGFzc3dvcmQxMjM=)


> so instead of config map it is secret and let's change the name of this resource to mongodb-secret and 
> let's give only password in the secret for Simplicity please note that the data in the secret must be given as base64 encoded data.
> To encode a text from the command line all we need to do is ==> echo -n password | base64 . (echo -n <plain text> | base64) 
> so (cGFzc3dvcmQxMjM=) this is the base64 encoded data for the password string .
> We can give any number of keys just like we gave in config map.

> kubernetes provides different types of Secrets. for arbitrary-user defined-data we should use opaque secret type. 
> So let's keep opaque as the type as we are storing the arbitrary data.
>To refer to this secret data from the port all we need to do is go back to the stateful set and change this config map to secret key ref and also change the secret name to mongodb-secret that's it now this password will be read from the secret.
>let's delete the password from the config map.

apiVersion: v1
kind: ConfigMap
metadata: 
  name: mongodb-config
immutable: false
data:
  username: admin1         (key is username & admin1 is value)
  mongodb.conf: |           (key & file name)
  storage:
    dbPath: /data/db  => (configDB to just db)
  replication:
      replSetName: "rs0

> so let's apply them ==> let's apply the config map first.=> kubectl apply -f mongo-configmap.yml
> let's apply the secret now. =>  kubectl apply -f mongo-secret.yml
> let's try to delete the stateful set and create again==> ## kubectl delete -f statefulset.yml and let's apply again => kubectl apply -f statefulset.yml perfect.
> it's created let's get into the pod  ==> by the way Ctrl+R is used for the searching and I'm just searching exec so that it will list down all the commands that matches this text and until you find the command that you want from the history just keep pressing Ctrl+R
> so that you'll get that command just enter now .
> we are in the pod and let's try to list down the environment variables => env and as you can see we are getting the data from the secret just like we updated the config map we can update the secrets too.
> so let's change the password and see.
> so instead of password I'm just typing password123 enter and this is the base64 encoded data for password123.  => echo -n password123 | base64 => 56451ffefhwuwkbx8
> I'm just pasting here and applying the secret the secret is updated.
> Now let's delete the mongo-0  pod and see if it is reflected or not => kubectl delete pod mongo-0 so it should recreate the pod.
> now let's get into the pod==>  ## kubectl exec -it mongo-0 --bash ==> and as you can see the password is updated here.
> please note that we are encoding this data not encrypting this means this can be easily decoded with ==> echo -n <base 64 encoded data> | base64 -- decode
> As you can see this is the decoded data.
> so we should make sure to restrict the access to Secrets also we can easily read the secrets by getting into the Pod just like we did the environment variables.
> we will learn more about restricting access to the kubernetes resources in later sections.
> so choosing between config map and secret is very simple .
> if you want to store nonsensitive plane configuration data just go with config map.
> if you want to store any sensitive data go with secret.
> if your configuration data includes both sensitive and non-sensitive data then you must go with the secrets.


